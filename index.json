[{"content":"I recently wrote an integration test framework for a Kafka pipeline using Cucumber and Testcontainers. This is part 2 of a series explaining how, in which we\u0026rsquo;ll start Kafka using the Testcontainers library.\nPart 1 is here if you want to see how to set up Cucumber to run tests from Maven \u0026amp; your IDE.\nwhat is testcontainers? I\u0026rsquo;ll cover Testcontainers more fully in a separate post some time but, for now, we just need to know that Testcontainers is a rather amazing library for starting infrastructure such as databases or messaging systems in Docker containers at test-time. In fact, it can be used to start anything that can run in a container. The library manages the lifecycle of those containers shutting them down cleanly on test completion.\nWe\u0026rsquo;ll need to add two Testcontainers dependencies to our pom to use it - org.testcontainers:testcontainers and org.testcontainers:kafka.\ncucumber lifecycle hooks Starting containers takes a little time so we want to share the containers between our Cucumber scenarios. When using Testcontainers with JUnit Jupiter this is easy using the annotations @Testcontainers and @Container. When the latter is applied to a static field, Testcontainers will start containers \u0026amp; share them amongst our JUnit @Test methods.\nCucumber does have its own @Before annotation triggered before each scenario but it does not have the @BeforeAll1 we\u0026rsquo;d ideally like to cleanly implement container sharing.\npipeline plugin I looked at a couple of options to overcome the lack of an appropriate hook but settled on a solution that used Cucumber\u0026rsquo;s Plugin mechanism. This allows us to listen to Cucumber lifecycle events and start our containers exactly once.\nMy initial plugin looks like this:\npublic class IngestionPipeline implements EventListener { private KafkaContainer kafkaContainer; private final EventHandler\u0026lt;TestRunStarted\u0026gt; startUp = new EventHandler\u0026lt;\u0026gt;() { private static final String CONFLUENT_VERSION = \u0026#34;6.0.1\u0026#34;; @Override public void receive(TestRunStarted testRunStarted) { kafkaContainer = new KafkaContainer( DockerImageName.parse(\u0026#34;confluentinc/cp-kafka\u0026#34;) .withTag(CONFLUENT_VERSION) ).withLogConsumer( new Slf4jLogConsumer( LoggerFactory.getLogger(\u0026#34;kafka-container\u0026#34;) ).withSeparateOutputStreams() ); kafkaContainer.start(); } }; private final EventHandler\u0026lt;TestRunFinished\u0026gt; shutDown = new EventHandler\u0026lt;\u0026gt;() { @Override public void receive(TestRunFinished testRunFinished) { kafkaContainer.stop(); } }; @Override public void setEventPublisher(EventPublisher publisher) { publisher.registerHandlerFor(TestRunStarted.class, startUp); publisher.registerHandlerFor(TestRunFinished.class, shutDown); } } What is going on here?\n We are registering two listeners - startUp to be notified of TestRunStarted events \u0026amp; shutDown to be notified of TestRunFinished events. In the first of these, we are creating \u0026amp; starting a Docker container running Kafka (the image we are using actually includes Zookeeper too). We are doing this using the Testcontainers class KafkaContainer.2 We are attaching a logger to the container to capture and log its output. By using withSeparateOutputStreams() Testcontainers will split the stderr \u0026amp; stdout output of the container and log them at ERROR \u0026amp; INFO levels respectively. In shutDown we are stopping the container.  To get Cucumber to recognise \u0026amp; use this plugin, we need to add the fully qualified class name to cucumber.properties and junit-platform.properties.\nrun it! Assuming we already have Docker installed, if we now run our tests, we\u0026rsquo;ll see the Docker image being downloaded (this is a one-time activity) and the container starting.\nWe just started a Kafka instance with only a few lines of code! Next time we\u0026rsquo;ll introduce our application \u0026amp; start that too.\ntestcontainers.\ncucumber.\ncucumber-jvm.\nsource3.\n  See this issue for a discussion of workarounds. \u0026#x21a9;\u0026#xfe0e;\n In addition to its GenericContainer that can be used to start just about anything in a container , Testcontainers provides a handful of technology-specific classes like KafkaContainer where they add some useful functionality over and above the GenericContainer. \u0026#x21a9;\u0026#xfe0e;\n The repository is tagged at 1.1 to indicate the version of it that goes with this part of the series. \u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://www.codecrumbs.dev/posts/cucumber-part2/","summary":"I recently wrote an integration test framework for a Kafka pipeline using Cucumber and Testcontainers. This is part 2 of a series explaining how, in which we\u0026rsquo;ll start Kafka using the Testcontainers library.\nPart 1 is here if you want to see how to set up Cucumber to run tests from Maven \u0026amp; your IDE.\nwhat is testcontainers? I\u0026rsquo;ll cover Testcontainers more fully in a separate post some time but, for now, we just need to know that Testcontainers is a rather amazing library for starting infrastructure such as databases or messaging systems in Docker containers at test-time.","title":"cucumber and testcontainers"},{"content":"I recently wrote an integration test framework for a Kafka pipeline using Cucumber and Testcontainers. This is part 1 of a series explaining how, starting with setting up our project to be able to run Cucumber tests from maven \u0026amp; our IDE (IntelliJ in my case).\nwhy cucumber? I\u0026rsquo;d previously written a couple of integration test frameworks triggered from JUnit @Test methods. These both used fluent APIs to set up the required environment \u0026amp; execute the test, hiding the plumbing from the test author.\nThis worked well in a team where the developers wrote most of the tests. This time around and on a different project I wanted tests that could be maintained by less-technical folks and hopefully replace separate acceptance criteria in stories.\nI looked at a couple of BDD frameworks to achieve this and liked the look of Cucumber.\nfeatures and steps The key technical differences between writing a JUnit test and a Cucumber test (one implemented in Java at least) are that the tests are defined in feature files and use steps which are defined in a class file.\nThe feature file is written in Gherkin, a business-readable language for defining behaviour. It has a few keywords used to define the preconditions, stimulus \u0026amp; expected outcome of the test in a Given-When-Then format.\nThe example used in the 10min Cucumber tutorial looks a bit like this:\nFeature:Is it Friday yet? Everybody wants to know when it\u0026#39;s Friday Scenario:Sunday isn\u0026#39;t Friday Given today is Sunday When I ask whether it\u0026#39;s Friday yet Then I should be told \u0026#34;Nope\u0026#34; \u0026hellip; and the corresponding step definitions look like this (where IsItFriday is the \u0026lsquo;system\u0026rsquo; under test):\npublic class StepDefinitions { private String today; private String actualAnswer; @Given(\u0026#34;today is Sunday\u0026#34;) public void todayIsSunday() { today = \u0026#34;Sunday\u0026#34;; } @When(\u0026#34;I ask whether it\u0026#39;s Friday yet\u0026#34;) public void iAskWhetherItIsFridayYet() { actualAnswer = IsItFriday.isItFriday(today); } @Then(\u0026#34;I should be told {string}\u0026#34;) public void iShouldBeTold(String expectedAnswer) { assertEquals(expectedAnswer, actualAnswer); } } (I am showing annotation-based step definitions here as I personally find them more readable than the lambda alternatives available as part of cucumber-java8).\nsystem under test (SUT) My real SUT involved multiple kafka-steams components and a number of topics but here we\u0026rsquo;ll use a simplified example with a single kafka-stream that will receive details of orders that have been placed from one topic, enrich them with details of the (existing) customer that placed the order and provide a summary of the order to the sales team via another topic.\nAll messages will be in json.\nproject set-up The build-tool support for using Cucumber with JUnit 5 still has some gaps compared to the support for JUnit 4 (mostly around test discovery in Surefire) but I didn\u0026rsquo;t want to start a new project using an older version of JUnit so we\u0026rsquo;ll use JUnit 5 here.\nOur initial project structure will look like this:\npom.xml src test java dev.codecrumbs.sales.test.steps StepDefinitions.java features IntegrationTests.java resources cucumber.properties junit-platform.properties features sales-ingestion.feature A few things to note:\n In the pom, we depend on cucumber-junit-platform-engine \u0026amp; cucumber-java. The former allows us to run Cucumber tests using the JUnit platform1 \u0026amp; the latter contains the annotations used to define test steps. For feature files to be found (by surefire at least), it is necessary to have a class annotated with @Cucumber in the same package. In our case this is named IntegrationTests. cucumber.properties contains settings that customise Cucumber (just output formatting for now) and is used by the Cucumber CLI when executing tests from your IDE. junit-platform.properties is identical to cucumber.properties but is used by surefire. This duplication is an annoyance I have yet to resolve.  first feature sales-ingestion.feature looks like this:\nFeature:Sales are ingested. Scenario:Details of a sale are ingested. Scenario Outline: Given An existing customer \u0026#34;\u0026lt;customer\u0026gt;\u0026#34; exists. When Order \u0026#34;\u0026lt;order\u0026gt;\u0026#34; is placed. Then The Sales Team are notified of Order \u0026#34;\u0026lt;summary\u0026gt;\u0026#34;. Scenarios: | customer| order| summary||john-smith|five-apples|john-smiths-apples| We have a single parameterized scenario that allows us to execute the same test multiple times with different inputs \u0026amp; expected outputs. These appear in the Scenarios table. As our inputs \u0026amp; expected outputs will be json, I didn\u0026rsquo;t want to clutter my features with inline json so intend to have customer, order and summary refer to external files.\nthe step definitions public class StepDefinitions { private static final Logger LOG = LoggerFactory.getLogger(StepDefinitions.class); @Given(\u0026#34;An existing customer {string} exists.\u0026#34;) public void anExistingCustomer(String existingCustomer) { LOG.info(\u0026#34;Loading existing customer {}\u0026#34;, existingCustomer); } @When(\u0026#34;Order {string} is placed.\u0026#34;) public void orderIsReceived(String order) { LOG.info(\u0026#34;Injecting order {}\u0026#34;, order); } @Then(\u0026#34;The Sales Team are notified of Order {string}.\u0026#34;) public void salesTeamAreNotifiedOfOrder(String orderSummary) { LOG.info( \u0026#34;Verifying that order summary {} is received by sales team.\u0026#34;, orderSummary ); } } These step definitions will interact with the system-under test but, for now, we are just logging that the step was executed.\nrunning our tests The tests should now run as part of the maven build and from our IDE. They look like this in IntelliJ:\nNext time we\u0026rsquo;ll extend this to start Kafka using Testcontainers.\ncucumber.\ncucumber-jvm.\nsource2.\n  If you weren\u0026rsquo;t aware, as of version 5, JUnit has been split into a platform \u0026amp; engines for running different kinds of tests. You may be familiar with Jupiter (containing the annotations \u0026amp; support for running Java unit tests) \u0026amp; Vintage (for running JUnit 4 tests on the JUnit 5 platform). Cucumber works with JUnit 5 by providing its own engine too. \u0026#x21a9;\u0026#xfe0e;\n The repository is tagged at 1.0 to indicate the version of it that goes with this part of the series. \u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://www.codecrumbs.dev/posts/cucumber-part1/","summary":"I recently wrote an integration test framework for a Kafka pipeline using Cucumber and Testcontainers. This is part 1 of a series explaining how, starting with setting up our project to be able to run Cucumber tests from maven \u0026amp; our IDE (IntelliJ in my case).\nwhy cucumber? I\u0026rsquo;d previously written a couple of integration test frameworks triggered from JUnit @Test methods. These both used fluent APIs to set up the required environment \u0026amp; execute the test, hiding the plumbing from the test author.","title":"cucumber set up"},{"content":"I have yet to work on a project where we have attempted to test the log statements in the software \u0026amp; I\u0026rsquo;ve recently found myself asking why.\nLog statements added by different developers (sometimes guided by a woolly statement on logging in the project coding guidelines) vary in their number, style \u0026amp; usefulness. Logging ends up inconsistent in its level of detail, format \u0026amp; log level.\nThe logging of the same event could end up like any of the following:\n1: Saving order... 2: Creating order for customer [123] for [5] items with value [Â£56.20]... 3: Adding order [ customer: { ... // full details of customer }, items: { ... // full details of all items }, ... ] In this environment, diagnosing the cause of production issues frequently involves tweaking the log level for certain packages in the hope that the application gives up its secrets and deploying patches with additional log statements when it doesn\u0026rsquo;t.\nIt seems clear that we do care about logging \u0026amp; it is an important part of what we deliver.\nIf we are using AOP to consistently apply logging at the boundary to certain layers and have no other logging, that\u0026rsquo;s great. Testing those log statements is probably less valuable. If not, we need a solution.\nLogCaptor LogCaptor is a simple library that allows us to capture logging from the system under test and make assertions about it. It looks like this:\nclass WidgetServiceTest { private final LogCaptor logCaptor = LogCaptor.forClass(WidgetService.class); ... @Test void testAdd() { String name = \u0026#34;My Widget\u0026#34;; service.add(Widget.of(name)); assertThat(logCaptor.getDebugLogs()) .containsExactly( String.format(\u0026#34;Adding widget with name [%s]\u0026#34;, name) ); } } (this example is also using the awesome AssertJ)\nThe LogCaptor class provides methods for getting the logged messages as a list of LogEvent or strings. For the latter, these can be restricted to a particular logging level.\nThe full LogEvent is useful for more complex assertions. It provides access to arguments and any Throwable as well as the message \u0026amp; log level. The following example shows a test of a log statement that includes an exception.\n@Test void testRemoveWithIllegalId() { int illegalId = -1; assertThatIllegalArgumentException() .isThrownBy(() -\u0026gt; service.remove(illegalId)); List\u0026lt;LogEvent\u0026gt; logEvents = logCaptor.getLogEvents(); assertThat(logEvents) .hasOnlyOneElementSatisfying( event -\u0026gt; { assertThat(event.getMessage()) .isEqualTo(\u0026#34;Error removing widget\u0026#34;); assertThat(event.getLevel()) .isEqualTo(\u0026#34;ERROR\u0026#34;); assertThat(event.getThrowable()) .isPresent() .get(as(InstanceOfAssertFactories.THROWABLE)) .hasMessage( String.format( \u0026#34;Widget id must be greater than 0 but was [%s]\u0026#34;, illegalId ) ) .isInstanceOf(IllegalArgumentException.class); } ); } It works with all common logging libraries and with the Lombok logging annotations.\nThat\u0026rsquo;s LogCaptor.\nlogcaptor.\nassertj.\nsource.\n","permalink":"https://www.codecrumbs.dev/posts/testing-logging/","summary":"I have yet to work on a project where we have attempted to test the log statements in the software \u0026amp; I\u0026rsquo;ve recently found myself asking why.\nLog statements added by different developers (sometimes guided by a woolly statement on logging in the project coding guidelines) vary in their number, style \u0026amp; usefulness. Logging ends up inconsistent in its level of detail, format \u0026amp; log level.\nThe logging of the same event could end up like any of the following:","title":"test your logging"},{"content":"This is my blog, codecrumbs. I\u0026rsquo;m a software developer specialising in Java with a particular interest in developer testing. I started blogging mainly to help me clarify my own thoughts and perhaps remember them beyond the end of the week.\nIn the unlikely event that it benefits someone else, that\u0026rsquo;s great.\n","permalink":"https://www.codecrumbs.dev/about/","summary":"This is my blog, codecrumbs. I\u0026rsquo;m a software developer specialising in Java with a particular interest in developer testing. I started blogging mainly to help me clarify my own thoughts and perhaps remember them beyond the end of the week.\nIn the unlikely event that it benefits someone else, that\u0026rsquo;s great.","title":"about"},{"content":"","permalink":"https://www.codecrumbs.dev/search/","summary":"search","title":"search"}]